# 动态规划专题
## 动态规划的本质：
为什么要进行状态转移？**通过将问题具体化，缩小化，以至于到能够解决的地步。**
> 举一个字符串匹配的问题，例如，要**寻找区间[0, i]和[0, j]中**相同的子序列的最大值，对于dp[i][j]我们如何将这个问题进行细化，或者说将问题缩小一点，显然我们需要添加一些已知条件，通过已知条件，来将问题变小一点，如当前的s[i]和t[j]的相匹配的情况，如果说二者相匹配，那么问题就从就缩小了，至少不用再考虑i , j而是直接考虑i- 1， j - 1;如果二者不匹配，这同样帮我们缩小了访问，因为我们可以把问题分成两个比原问题要小一些的问题，即[0, i - 1] 和 [0 , j]的情况，以及[0 , i] 和 [0, j - 1]的情况。**显然，问题范围的缩小是建立在当前能贡献出一些已知条件的基础上的**，通过已知条件，删掉一些不用再考虑的范围，这才是dp的核心思想。



## 刷表法和填表法：
> 方法介绍：   
> 在dp问题中，当我们写出了状态转移方程的时候，一般可以直接去迭代求解。但是，与此同时有一个问题：例如 状态转移方程 是dp[i][j]=F{dp[i-1][j-1],dp[i-1][j],dp[i-1][j-1]} 这样的形态时，如何进行枚举呢？是枚举dp[i][j]，由dp[i-1][j-1],dp[i-1][j],dp[i-1][j-1]更新dp[i][j]，抑或是枚举dp[i-1][j-1]，去更新dp[i+1][j+1],dp[i+1][j],dp[i][j+1]。
**填表法：可以枚举 dp[i][j],然后用dp[i-1][j-1],dp[i-1][j],dp[i][j-1]去更新他**这就叫做填表法，就好像在填表格的一个一个空格一样，枚举未知量，现在的未知量可以由已知量求出。
**刷表法：也可以使用d[i][j]去更新dp[i+1][j]和dp[i+1][j+1],dp[i][j+1]的值，枚举已知量**，并且依据此更新依赖于它的未知量状态**注意此时的未知量可以是之前的，也可以是之后的**。
通常使用的都是比较直观的填表法，但是当状态转移方程比较难以写成当前状态dp[i][j]由哪些先前的状态转化而来，反而更容易写成/理解到当前的状态会影响哪些后续状态，那么就适合使用刷表法。我感觉一般刷表法的思考难度会高一些。  
相应例题：https://leetcode.cn/problems/solving-questions-with-brainpower/?envType=study-plan-v2&envId=dynamic-programming





## 字符串专题
### 题型分类
类型主要有两种：
* 两个字符串匹配问题
* 单个字符串问题，如回文、单词拆分

字符串问题的dp数组通常是二维的，即dp[i][j]，状态由三种情况转移而来，dp[i-1][j-1],dp[i-1][j],dp[i][j-1],该如何选择这三种情况呢？
* 如果说有一个维度在转移时被固定住，则只能改变另一个维度  
    例如：“不同的子序列”， 要寻找[0, i] 中 [0, j]的出现次数，此时j这个数字就是被固定住的，**因为前者必须包含[0, j]这个整体，而不是一部分**，所以j的数字不能变    
    ~~~c++
    //定义dp[i][j]表示[0, i] 中 [0, j]的出现次数
         if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
         else dp[i][j] = dp[i - 1][j];
    ~~~
    有一道题和“不同的子序列问题很像” —— 最长公共子序列，寻找[0,i]和[0,j]的公共子序列中的最长的，这道题和上面一题的区别在于**j的数字不是固定的，也就是说我要寻找的可能是[0, j]的一部分，j的这一层维数就可以改变了**
    ~~~c++
    for(int i = 1 ; i <= n ; i++)
        {
            for(int j = 1 ; j <= m ; j++)
            {
                if(text1[i-1] == text2[j-1])
                dp[i][j] = dp[i-1][j-1] + 1;
                else dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);
                ans = max(ans,dp[i][j]);
            }
        
        }
    ~~~   
* 如果当前两个位数满足某种条件，**通常是匹配或者相等**，那么两个维数都要改变，如果二者不匹配，则通常是只改变一个维数
    例如：寻找最长回文子序列 在不匹配时，就是只改变一个维数
    ~~~c++
    for(int i = n-1 ; i >= 0 ; i--)
        {
            for(int j = i+1 ; j < n ; j++)
            {
                if(s[i] == s[j])
                {
                    dp[i][j] = dp[i+1][j-1] + 2;
                }
                else
                { 
                    dp[i][j] = max(dp[i+1][j] , dp[i][j-1]);// 最大值出现在包括左边界或者右边界
                }
            }
        }
    ~~~
    也有在不匹配时改变两个维数：编辑距离
    ~~~c++
    for(int i = 1; i < n1 + 1; i ++){
            for(int j = 1; j < n2 + 1; j++){
                if(word1[i -  1] == word2[j - 1]){ //匹配则直接继承
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else{
                    dp[i][j] = min(dp[i][j - 1], min(dp[i - 1][j - 1], dp[i - 1][j])) + 1; //不匹配，则都不要或者只要其中的一个
                }
            }
        }
    ~~~


